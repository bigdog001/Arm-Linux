<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<title>C语言结构体的字节对齐原则 - shenbin1430的专栏 - 博客频道 - CSDN.NET</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="为什么要对齐?&nbsp;&nbsp;&nbsp;现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。&nbsp;&nbsp;&nbsp;对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特">
<script src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ga.js" async="" type="text/javascript"></script><script src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/jquery.js" type="text/javascript"></script>
<script src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/plugins.js" type="text/javascript"></script>
<script src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/common.js" type="text/javascript"></script>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ad.js"></script>
<link rel="Stylesheet" type="text/css" href="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/style.css">
<link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://blog.csdn.net/shenbin1430/rss/list">
<link rel="shortcut icon" href="http://blog.csdn.net/favicon.ico">
<link type="text/css" rel="stylesheet" href="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/default.css">
</head>
<body>
<script src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/pub_topnav_2011.js" type="text/javascript"></script><link rel="stylesheet" type="text/css" href="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/navtop_2012.css">
<div class="nav_top_2011">
<p><span style="color:red;">您还未登录！</span>|<a href="https://passport.csdn.net/account/login" target="_top">登录</a>|<a href="https://passport.csdn.net/account/register" target="_top">注册</a>|<a href="https://passport.csdn.net/help/faq" target="_blank">帮助</a></p><ul>
<li><a href="http://www.csdn.net/" target="_blank">首页</a></li>
<li><a href="http://news.csdn.net/" target="_blank">业界</a></li>
<li><a href="http://mobile.csdn.net/" target="_blank">移动</a></li>
<li><a href="http://cloud.csdn.net/" target="_blank">云计算</a></li>
<li><a href="http://sd.csdn.net/" target="_blank">研发</a></li>
<li><a href="http://bbs.csdn.net/" target="_blank">论坛</a></li>
<li><a href="http://blog.csdn.net/" target="_blank">博客</a></li>
<li><a href="http://download.csdn.net/" target="_blank">下载</a></li>
<li class="more"><h2 id="topnav_btnmore" onclick="showNavMore(this)"><a href="javascript:void(0);">更多</a></h2>
<div id="topnav_hidlist">
<iframe name="nav_frm" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/a.htm" frameborder="no" height="178" scrolling="no" width="92"></iframe>
</div>
</li>
</ul>
</div>


<div id="container">
<div id="header">
    <div class="header">
        <div id="blog_title">
            <h1><a href="http://blog.csdn.net/shenbin1430">shenbin1430的专栏</a></h1>
            <h2></h2>
            <div class="clear"></div>
        </div>
        <div class="clear"></div>
    </div>
</div>
<div id="navigator">
    <div class="navigator_bg"></div>
    <div class="navigator">
        <ul>
            <li id="btnContents"><a href="http://blog.csdn.net/shenbin1430?viewmode=contents"><span><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ico_list.gif">目录视图</span></a></li>
            <li id="btnView"><a href="http://blog.csdn.net/shenbin1430?viewmode=list"><span><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ico_summary.gif">摘要视图</span></a></li>
            <li id="btnRss"><a href="http://blog.csdn.net/shenbin1430/rss/list"><span><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ico_rss.gif">订阅</span></a></li>
</ul>
    </div>
</div>
<script type="text/javascript">
    var username = "shenbin1430";
    var blog_address = "http://blog.csdn.net/shenbin1430";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";
</script>
        
<div id="body">
<div id="main">
<div class="main">
<div class="notice"> 

<a href="http://blog.csdn.net/csdnproduct/article/details/8206587" target="_blank">
<font color="red">
公告：CSDN 搜索第二版正式上线！  </font></a>

&nbsp;&nbsp;

<a href="http://bbs.csdn.net/topics/390312398" target="_blank"><font color="red">CSDN论坛2012年度职场优秀帖评选活动正式开始！</font></a>

&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/zhangoi391/article/details/8161343" target="_blank">
<font color="red">2000元大奖征异构开发博文  </font></a>

<br>





<a href="http://vote.blog.csdn.net/details/blogstar" target="_blank">
<font color="red">2012CSDN博客之星评选正式上线 </font></a>

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://events.csdn.net/DR2012/roadshow/index.html" target="_blank">
<font color="red">【免费】解读海外市场营销奥秘   </font></a>

&nbsp;&nbsp;&nbsp;&nbsp;

<a href="http://blog.csdn.net/csdnproduct/article/details/8101993" target="_blank">
<font color="red">CSDN博客频道推出TAG功能  </font></a>

</div><div id="article_details" class="details">
    <div class="article_title">
    <span class="ico ico_type_Original"></span>
    <h3>
        <span class="link_title"><a href="http://blog.csdn.net/shenbin1430/article/details/4292463">
        C语言结构体的字节对齐原则
        </a></span>
    </h3>
</div>

        
    <div class="article_manage">
        <span class="link_categories">
        分类：
            <a href="http://blog.csdn.net/shenbin1430/article/category/558503">程序设计</a> 
        </span>
    <span class="link_postdate">2009-06-23 18:27</span>
    <span class="link_view" title="阅读次数">1284人阅读</span>
    <span class="link_comments" title="评论次数"><a href="#comments">评论</a>(1)</span>
    <span class="link_collect"><a href="javascript:void(0);" onclick="javascript:collectArticle('C语言结构体的字节对齐原则','4292463');return false;" title="收藏">收藏</a></span>
    <span class="link_report"><a href="#report" onclick="javascript:report(4292463,2);return false;" title="举报">举报</a></span>
    
</div>


    
<div id="article_content" class="article_content">
<p style="text-indent: 2em;">为什么要对齐?</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特
定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;
对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问
一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对
数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那
么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数
据。显然在读取效率上下降很多。</p>
<p style="text-indent: 2em;">二.字节对齐对程序的影响:</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; 先让我们看几个例子吧(32bit,x86环境,gcc编译器):</p>
<p style="text-indent: 2em;">设结构体如下定义：</p>
<p style="text-indent: 2em;">struct A</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; short c;</p>
<p style="text-indent: 2em;">};</p>
<p style="text-indent: 2em;">struct B</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; short c;</p>
<p style="text-indent: 2em;">};</p>
<p style="text-indent: 2em;">现在已知32位机器上各种数据类型的长度如下:</p>
<p style="text-indent: 2em;">char:1(有符号无符号同)&nbsp;&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">short:2(有符号无符号同)&nbsp;&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">int:4(有符号无符号同)&nbsp;&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">long:4(有符号无符号同)&nbsp;&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">float:4&nbsp;&nbsp;&nbsp; double:8</p>
<p style="text-indent: 2em;">那么上面两个结构大小如何呢?</p>
<p style="text-indent: 2em;">结果是:</p>
<p style="text-indent: 2em;">sizeof(strcut A)值为8</p>
<p style="text-indent: 2em;">sizeof(struct B)的值却是12</p>
<p style="text-indent: 2em;">结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样;按理说A,B大小应该都是7字节。</p>
<p style="text-indent: 2em;">之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果,那么我们是不是可以改变编译器的这种默认对齐设置呢,当然可以.例如:</p>
<p style="text-indent: 2em;">#pragma pack (2) /*指定按2字节对齐*/</p>
<p style="text-indent: 2em;">struct C</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; short c;</p>
<p style="text-indent: 2em;">};</p>
<p style="text-indent: 2em;">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</p>
<p style="text-indent: 2em;">sizeof(struct C)值是8。</p>
<p style="text-indent: 2em;">修改对齐值为1：</p>
<p style="text-indent: 2em;">#pragma pack (1) /*指定按1字节对齐*/</p>
<p style="text-indent: 2em;">struct D</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; short c;</p>
<p style="text-indent: 2em;">};</p>
<p style="text-indent: 2em;">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</p>
<p style="text-indent: 2em;">sizeof(struct D)值为7。</p>
<p style="text-indent: 2em;">后面我们再讲解#pragma pack()的作用.</p>
<p style="text-indent: 2em;">三.编译器是按照什么样的原则进行对齐的?</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; 先让我们看四个重要的基本概念：</p>
<p style="text-indent: 2em;">1.数据类型自身的对齐值：</p>
<p style="text-indent: 2em;">&nbsp; 对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。</p>
<p style="text-indent: 2em;">2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</p>
<p style="text-indent: 2em;">3.指定对齐值：#pragma pack (value)时的指定对齐值value。</p>
<p style="text-indent: 2em;">4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</p>
<p style="text-indent: 2em;">有
了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是
表示“对齐在N上”，也就是说该数据的"存放起始地址%N=0".而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数
据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数
倍，结合下面例子理解)。这样就不能理解上面的几个例子的值了。</p>
<p style="text-indent: 2em;">例子分析：</p>
<p style="text-indent: 2em;">分析例子B；</p>
<p style="text-indent: 2em;">struct B</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; short c;</p>
<p style="text-indent: 2em;">};</p>
<p style="text-indent: 2em;">假
设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定
对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0.第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，
所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c,自身对齐值为
2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的
都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，
0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x0000A到0x000B也为结构体B所占用。故B从0x0000到0x000B
共有12个字节,sizeof(struct B)=12;其实如果就这一个就来说它已将满足字节对齐了,
因为它的起始地址是0,因此肯定是对齐的,之所以在后面补充2个字节,是因为编译器为了实现结构数组的存取效率,试想如果我们定义了一个结构B的数组,那
么第一个结构起始地址是0没有问题,但是第二个结构呢?按照数组的定义,数组中所有元素都是紧挨着的,如果我们不把结构的大小补充为4的整数倍,那么下一
个结构的起始地址将是0x0000A,这显然不能满足结构的地址对齐了,因此我们要把结构补充成有效对齐大小的整数倍.其实诸如:对于char型数据，其
自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的,只
是因为这些类型的长度已知了,所以他们的自身对齐值也就已知了.</p>
<p style="text-indent: 2em;">同理,分析上面例子C：</p>
<p style="text-indent: 2em;">#pragma pack (2) /*指定按2字节对齐*/</p>
<p style="text-indent: 2em;">struct C</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; short c;</p>
<p style="text-indent: 2em;">};</p>
<p style="text-indent: 2em;">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</p>
<p style="text-indent: 2em;">第
一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=
0;第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续
字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放</p>
<p style="text-indent: 2em;">在0x0006、0x0007中，符合
0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0,C
只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8.</p>
<p style="text-indent: 2em;">四.如何修改编译器的默认对齐值?</p>
<p style="text-indent: 2em;">1.在VC IDE中，可以这样修改：[Project]|[Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</p>
<p style="text-indent: 2em;">2.在编码时，可以这样动态修改：#pragma pack .注意:是pragma而不是progma.</p>
<p style="text-indent: 2em;">五.针对字节对齐,我们在编程中如何考虑?</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;
如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0,然后各个变量按照上面的原则进行排列即可,基本的原则就是把结构中的变量按照
类型大小从小到大声明,尽量减少中间的填补空间.还有一种就是为了以空间换取时间的效率,我们显示的进行填补空间进行对齐,比如:有一种使用空间换时间做
法是显式的插入reserved成员：</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct A{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char reserved[3];//使用空间换时间</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int b;</p>
<p style="text-indent: 2em;">}</p>
<p style="text-indent: 2em;">reserved成员对我们的程序没有什么意义,它只是起到填补空间以达到字节对齐的目的,当然即使不加这个成员通常编译器也会给我们自动填补对齐,我们自己加上它只是起到显式的提醒作用.</p>
<p style="text-indent: 2em;">六.字节对齐可能带来的隐患:</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp; 代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：</p>
<p style="text-indent: 2em;">unsigned int i = 0x12345678;</p>
<p style="text-indent: 2em;">unsigned char *p=NULL;</p>
<p style="text-indent: 2em;">unsigned short *p1=NULL;</p>
<p style="text-indent: 2em;">p=&amp;i;</p>
<p style="text-indent: 2em;">*p=0x00;</p>
<p style="text-indent: 2em;">p1=(unsigned short *)(p+1);</p>
<p style="text-indent: 2em;">*p1=0x0000;</p>
<p style="text-indent: 2em;">最后两句代码，从奇数边界去访问unsignedshort型变量，显然不符合对齐的规定。</p>
<p style="text-indent: 2em;">在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error,因为它们要求必须字节对齐.</p>
<p style="text-indent: 2em;">七.如何查找与字节对齐方面的问题:</p>
<p style="text-indent: 2em;">如果出现对齐或者赋值问题首先查看</p>
<p style="text-indent: 2em;">1. 编译器的big little端设置</p>
<p style="text-indent: 2em;">2. 看这种体系本身是否支持非对齐访问</p>
<p style="text-indent: 2em;">3. 如果支持看设置了对齐与否,如果没有则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</p>
<p style="text-indent: 2em;">&nbsp;ARM下的对齐处理 </p>
<p style="text-indent: 2em;">from DUI0067D_ADS1_2_CompLib </p>
<p style="text-indent: 2em;">3.13 type&nbsp; qulifiers </p>
<p style="text-indent: 2em;">有部分摘自ARM编译器文档对齐部分</p>
<p style="text-indent: 2em;">对齐的使用:</p>
<p style="text-indent: 2em;">1.__align(num)</p>
<p style="text-indent: 2em;">&nbsp;&nbsp; 这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时</p>
<p style="text-indent: 2em;">&nbsp;&nbsp; 就要用到此命令__align(8)进行修饰限制。来保证数据对象是相应对齐。</p>
<p style="text-indent: 2em;">&nbsp;&nbsp; 这个修饰对象的命令最大是8个字节限制,可以让2字节的对象进行4字节</p>
<p style="text-indent: 2em;">&nbsp;&nbsp; 对齐,但是不能让4字节的对象2字节对齐。</p>
<p style="text-indent: 2em;">&nbsp;&nbsp; __align是存储类修改,他只修饰最高级类型对象不能用于结构或者函数对象。</p>
<p style="text-indent: 2em;">&nbsp;</p>
<p style="text-indent: 2em;">2.__packed </p>
<p style="text-indent: 2em;">&nbsp; __packed是进行一字节对齐</p>
<p style="text-indent: 2em;">&nbsp; 1.不能对packed的对象进行对齐</p>
<p style="text-indent: 2em;">&nbsp; 2.所有对象的读写访问都进行非对齐访问</p>
<p style="text-indent: 2em;">&nbsp; 3.float及包含float的结构联合及未用__packed的对象将不能字节对齐</p>
<p style="text-indent: 2em;">&nbsp; 4.__packed对局部整形变量无影响</p>
<p style="text-indent: 2em;">&nbsp; 5.强制由unpacked对象向packed对象转化是未定义,整形指针可以合法定</p>
<p style="text-indent: 2em;">&nbsp; 义为packed。</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp; __packed int* p;&nbsp; //__packed int 则没有意义</p>
<p style="text-indent: 2em;">&nbsp; 6.对齐或非对齐读写访问带来问题</p>
<p style="text-indent: 2em;">&nbsp; __packed struct STRUCT_TEST</p>
<p style="text-indent: 2em;">&nbsp;{</p>
<p style="text-indent: 2em;">&nbsp; char a;</p>
<p style="text-indent: 2em;">&nbsp; int b;</p>
<p style="text-indent: 2em;">&nbsp; char c;</p>
<p style="text-indent: 2em;">&nbsp;}&nbsp; ;&nbsp;&nbsp;&nbsp; //定义如下结构此时b的起始地址一定是不对齐的</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from CL]</p>
<p style="text-indent: 2em;">//将下面变量定义成全局静态不在栈上 </p>
<p style="text-indent: 2em;">static char* p;</p>
<p style="text-indent: 2em;">static struct STRUCT_TEST a;</p>
<p style="text-indent: 2em;">void Main()</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;__packed int* q;&nbsp; //此时定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</p>
<p style="text-indent: 2em;">&nbsp;p = (char*)&amp;a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">&nbsp;q = (int*)(p+1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">&nbsp;</p>
<p style="text-indent: 2em;">&nbsp;*q = 0x87654321; </p>
<p style="text-indent: 2em;">/*&nbsp;&nbsp; </p>
<p style="text-indent: 2em;">得到赋值的汇编指令很清楚</p>
<p style="text-indent: 2em;">ldr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r5,0x20001590 ; = #0x12345678</p>
<p style="text-indent: 2em;">[0xe1a00005]&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r0,r5</p>
<p style="text-indent: 2em;">[0xeb0000b0]&nbsp;&nbsp; bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __rt_uwrite4&nbsp; //在此处调用一个写4byte的操作函数 </p>
<p style="text-indent: 2em;">&nbsp;</p>
<p style="text-indent: 2em;">[0xe5c10000]&nbsp;&nbsp; strb&nbsp;&nbsp;&nbsp;&nbsp; r0,[r1,#0]&nbsp;&nbsp; //函数进行4次strb操作然后返回保证了数据正确的访问</p>
<p style="text-indent: 2em;">[0xe1a02420]&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2,r0,lsr #8</p>
<p style="text-indent: 2em;">[0xe5c12001]&nbsp;&nbsp; strb&nbsp;&nbsp;&nbsp;&nbsp; r2,[r1,#1]</p>
<p style="text-indent: 2em;">[0xe1a02820]&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2,r0,lsr #16</p>
<p style="text-indent: 2em;">[0xe5c12002]&nbsp;&nbsp; strb&nbsp;&nbsp;&nbsp;&nbsp; r2,[r1,#2]</p>
<p style="text-indent: 2em;">[0xe1a02c20]&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2,r0,lsr #24</p>
<p style="text-indent: 2em;">[0xe5c12003]&nbsp;&nbsp; strb&nbsp;&nbsp;&nbsp;&nbsp; r2,[r1,#3]</p>
<p style="text-indent: 2em;">[0xe1a0f00e]&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pc,r14</p>
<p style="text-indent: 2em;">*/</p>
<p style="text-indent: 2em;">/*</p>
<p style="text-indent: 2em;">如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败</p>
<p style="text-indent: 2em;">[0xe59f2018]&nbsp;&nbsp; ldr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2,0x20001594 ; = #0x87654321</p>
<p style="text-indent: 2em;">[0xe5812000]&nbsp;&nbsp; str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2,[r1,#0]</p>
<p style="text-indent: 2em;">*/</p>
<p style="text-indent: 2em;">//这样可以很清楚的看到非对齐访问是如何产生错误的</p>
<p style="text-indent: 2em;">//以及如何消除非对齐访问带来问题</p>
<p style="text-indent: 2em;">//也可以看到非对齐访问和对齐访问的指令差异导致效率问题</p>
<p style="text-indent: 2em;">}&nbsp;</p>
<p style="text-indent: 2em;">&nbsp;</p>
<p style="text-indent: 2em;">sizeof进行结构体大小的判断</p>
<p style="text-indent: 2em;">typedef struct</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;char b;</p>
<p style="text-indent: 2em;">}A_t;</p>
<p style="text-indent: 2em;">typedef struct</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;int a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;char b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;char c;</p>
<p style="text-indent: 2em;">}B_t;</p>
<p style="text-indent: 2em;">typedef struct</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;char a;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;int b;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;char c;</p>
<p style="text-indent: 2em;">}C_t;</p>
<p style="text-indent: 2em;">void main()</p>
<p style="text-indent: 2em;">{</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;char*a=0;</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;sizeof(a)&lt;&lt;endl;//4</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;sizeof(*a)&lt;&lt;endl;//1--这个能理解</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;sizeof(A_t)&lt;&lt;endl;//8</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;sizeof(B_t)&lt;&lt;endl;//8</p>
<p style="text-indent: 2em;">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;sizeof(C_t)&lt;&lt;endl;//12</p>
<p style="text-indent: 2em;">}</p>
<p style="text-indent: 2em;">为什么是这样的结果啊？ </p>
<p style="text-indent: 2em;">2. 语法： </p>
<p style="text-indent: 2em;">sizeof有三种语法形式，如下： </p>
<p style="text-indent: 2em;">1) sizeof( object ); // sizeof( 对象 ); </p>
<p style="text-indent: 2em;">2) sizeof( type_name ); // sizeof( 类型 ); </p>
<p style="text-indent: 2em;">3) sizeof object; // sizeof 对象; </p>
<p style="text-indent: 2em;">5. 指针变量的sizeof </p>
<p style="text-indent: 2em;">既然是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一</p>
<p style="text-indent: 2em;">个指针变量的返回值必定是4（以字节为单位），可以预计，在将来的64位系统</p>
<p style="text-indent: 2em;">中指针变量的sizeof结果为8。 </p>
<p style="text-indent: 2em;">char* pc = "abc"; </p>
<p style="text-indent: 2em;">int* pi; </p>
<p style="text-indent: 2em;">string* ps; </p>
<p style="text-indent: 2em;">char** ppc = &amp;pc; </p>
<p style="text-indent: 2em;">void (*pf)();// 函数指针 </p>
<p style="text-indent: 2em;">sizeof( pc ); // 结果为4 </p>
<p style="text-indent: 2em;">sizeof( pi ); // 结果为4 </p>
<p style="text-indent: 2em;">sizeof( ps ); // 结果为4 </p>
<p style="text-indent: 2em;">sizeof( ppc ); // 结果为4 </p>
<p style="text-indent: 2em;">sizeof( pf );// 结果为4 </p>
<p style="text-indent: 2em;">指针变量的sizeof值与指针所指的对象没有任何关系，正是由于所有的指针变量所占内存</p>
<p style="text-indent: 2em;">大小相等，所以MFC消息处理函数使用两个参数WPARAM、LPARAM就能传递各种复杂的消息结</p>
<p style="text-indent: 2em;">构（使用指向结构体的指针）。 </p>
<p style="text-indent: 2em;">6. 数组的sizeof </p>
<p style="text-indent: 2em;">数组的sizeof值等于数组所占用的内存字节数，如： </p>
<p style="text-indent: 2em;">char a1[] = "abc"; </p>
<p style="text-indent: 2em;">int a2[3]; </p>
<p style="text-indent: 2em;">sizeof( a1 ); // 结果为4，字符串末尾还存在一个NULL终止符 </p>
<p style="text-indent: 2em;">sizeof( a2 ); // 结果为3*4=12（依赖于int） </p>
<p style="text-indent: 2em;">一些朋友刚开始时把sizeof当作了求数组元素的个数，现在，你应该知道这是不对的，那</p>
<p style="text-indent: 2em;">么应该怎么求数组元素的个数呢？Easy，通常有下面两种写法： </p>
<p style="text-indent: 2em;">int c1 = sizeof( a1 ) / sizeof( char ); // 总长度/单个元素的长度 </p>
<p style="text-indent: 2em;">int c2 = sizeof( a1 ) / sizeof( a1[0] ); // 总长度/第一个元素的长度 </p>
<p style="text-indent: 2em;">写到这里，提一问，下面的c3，c4值应该是多少呢？ </p>
<p style="text-indent: 2em;">void foo3(char a3[3]) </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">int c3 = sizeof( a3 ); // c3 == </p>
<p style="text-indent: 2em;">} </p>
<p style="text-indent: 2em;">void foo4(char a4[]) </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">int c4 = sizeof( a4 ); // c4 == </p>
<p style="text-indent: 2em;">} </p>
<p style="text-indent: 2em;">也许当你试图回答c4的值时已经意识到c3答错了，是的，c3!=3。这里函数参数a3已不再是</p>
<p style="text-indent: 2em;">数组类型，而是蜕变成指针，相当于char* a3，为什么？仔细想想就不难明白，我们调用</p>
<p style="text-indent: 2em;">函数foo1时，程序会在栈上分配一个大小为3的数组吗？不会！数组是“传址”的，调用者</p>
<p style="text-indent: 2em;">只需将实参的地址传递过去，所以a3自然为指针类型（char*），c3的值也就为4。 </p>
<p style="text-indent: 2em;">7. 结构体的sizeof </p>
<p style="text-indent: 2em;">这是初学者问得最多的一个问题，所以这里有必要多费点笔墨。让我们先看一个结构体：</p>
<p style="text-indent: 2em;">struct S1 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char c; </p>
<p style="text-indent: 2em;">int i; </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">问sizeof(s1)等于多少？聪明的你开始思考了，char占1个字节，int占4个字节，那么加起</p>
<p style="text-indent: 2em;">来就应该是5。是这样吗？你在你机器上试过了吗？也许你是对的，但很可能你是错的！V</p>
<p style="text-indent: 2em;">C6中按默认设置得到的结果为8。 </p>
<p style="text-indent: 2em;">Why？为什么受伤的总是我？ </p>
<p style="text-indent: 2em;">请不要沮丧，我们来好好琢磨一下sizeof的定义——sizeof的结果等于对象或者类型所占</p>
<p style="text-indent: 2em;">的内存字节数，好吧，那就让我们来看看S1的内存分配情况： </p>
<p style="text-indent: 2em;">S1 s1 = {&nbsp;&nbsp;a , 0xFFFFFFFF }; </p>
<p style="text-indent: 2em;">定义上面的变量后，加上断点，运行程序，观察s1所在的内存，你发现了什么？ </p>
<p style="text-indent: 2em;">以我的VC6.0为例，s1的地址为0x0012FF78，其数据内容如下： </p>
<p style="text-indent: 2em;">0012FF78: 61 CC CC CC FF FF FF FF </p>
<p style="text-indent: 2em;">发现了什么？怎么中间夹杂了3个字节的CC？看看MSDN上的说明： </p>
<p style="text-indent: 2em;">When applied to a structure type or variable, sizeof returns the actual size, </p>
<p style="text-indent: 2em;">which may include padding bytes inserted for alignment. </p>
<p style="text-indent: 2em;">原来如此，这就是传说中的字节对齐啊！一个重要的话题出现了。 </p>
<p style="text-indent: 2em;">为什么需要字节对齐？计算机组成原理教导我们这样有助于加快计算机的取数速度，否则</p>
<p style="text-indent: 2em;">就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变</p>
<p style="text-indent: 2em;">量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度</p>
<p style="text-indent: 2em;">为4的基本数据类型（int等）都位于能被4整除的地址上，以此类推。这样，两个数中间就</p>
<p style="text-indent: 2em;">可能需要加入填充字节，所以整个结构体的sizeof值就增长了。 </p>
<p style="text-indent: 2em;">让我们交换一下S1中char与int的位置： </p>
<p style="text-indent: 2em;">struct S2 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">int i; </p>
<p style="text-indent: 2em;">char c; </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">看看sizeof(S2)的结果为多少，怎么还是8？再看看内存，原来成员c后面仍然有3个填充字</p>
<p style="text-indent: 2em;">节，这又是为什么啊？别着急，下面总结规律。 </p>
<p style="text-indent: 2em;">字节对齐的细节和编译器实现相关，但一般而言，满足三个准则： </p>
<p style="text-indent: 2em;">1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； </p>
<p style="text-indent: 2em;">2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有</p>
<p style="text-indent: 2em;">需要编译器会在成员之间加上填充字节（internal adding）； </p>
<p style="text-indent: 2em;">3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一</p>
<p style="text-indent: 2em;">个成员之后加上填充字节（trailing padding）。 </p>
<p style="text-indent: 2em;">对于上面的准则，有几点需要说明： </p>
<p style="text-indent: 2em;">1) 前面不是说结构体成员的地址是其大小的整数倍，怎么又说到偏移量了呢？因为有了第</p>
<p style="text-indent: 2em;">1点存在，所以我们就可以只考虑成员的偏移量，这样思考起来简单。想想为什么。 </p>
<p style="text-indent: 2em;">结构体某个成员相对于结构体首地址的偏移量可以通过宏offsetof()来获得，这个宏也在</p>
<p style="text-indent: 2em;">stddef.h中定义，如下： </p>
<p style="text-indent: 2em;">#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m) </p>
<p style="text-indent: 2em;">例如，想要获得S2中c的偏移量，方法为 </p>
<p style="text-indent: 2em;">size_t pos = offsetof(S2, c);// pos等于4 </p>
<p style="text-indent: 2em;">2) 基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型，</p>
<p style="text-indent: 2em;">这里所说的“数据宽度”就是指其sizeof的大小。由于结构体的成员可以是复合类型，比</p>
<p style="text-indent: 2em;">如另外一个结构体，所以在寻找最宽基本类型成员时，应当包括复合类型成员的子成员，</p>
<p style="text-indent: 2em;">而不是把复合成员看成是一个整体。但在确定复合类型成员的偏移位置时则是将复合类型</p>
<p style="text-indent: 2em;">作为整体看待。 </p>
<p style="text-indent: 2em;">这里叙述起来有点拗口，思考起来也有点挠头，还是让我们看看例子吧（具体数值仍以VC</p>
<p style="text-indent: 2em;">6为例，以后不再说明）： </p>
<p style="text-indent: 2em;">struct S3 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char c1; </p>
<p style="text-indent: 2em;">S1 s; </p>
<p style="text-indent: 2em;">char c2 </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，所以</p>
<p style="text-indent: 2em;">S3的最宽简单类型为int，这样，通过S3定义的变量，其存储空间首地址需要被4整除，整</p>
<p style="text-indent: 2em;">个sizeof(S3)的值也应该被4整除。 </p>
<p style="text-indent: 2em;">c1的偏移量为0，s的偏移量呢？这时s是一个整体，它作为结构体变量也满足前面三个准则</p>
<p style="text-indent: 2em;">，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需要了，</p>
<p style="text-indent: 2em;">所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补上3个填</p>
<p style="text-indent: 2em;">充字节。最后得到sizeof(S3)的值为16。 </p>
<p style="text-indent: 2em;">通过上面的叙述，我们可以得到一个公式： </p>
<p style="text-indent: 2em;">结构体的大小等于最后一个成员的偏移量加上其大小再加上末尾的填充字节数目，即： </p>
<p style="text-indent: 2em;">sizeof( struct ) = offsetof( last item ) + sizeof( last item ) + sizeof( trail</p>
<p style="text-indent: 2em;">ing padding ) </p>
<p style="text-indent: 2em;">到这里，朋友们应该对结构体的sizeof有了一个全新的认识，但不要高兴得太早，有一个</p>
<p style="text-indent: 2em;">影响sizeof的重要参量还未被提及，那便是编译器的pack指令。它是用来调整结构体对齐</p>
<p style="text-indent: 2em;">方式的，不同编译器名称和用法略有不同，VC6中通过#pragma pack实现，也可以直接修改</p>
<p style="text-indent: 2em;">/Zp编译开关。#pragma pack的基本用法为：#pragma pack( n )，n为字节对齐数，其取值</p>
<p style="text-indent: 2em;">为1、2、4、8、16，默认是8，如果这个值比结构体成员的sizeof值小，那么该成员的偏移</p>
<p style="text-indent: 2em;">量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值，公式如下： </p>
<p style="text-indent: 2em;">offsetof( item ) = min( n, sizeof( item ) ) </p>
<p style="text-indent: 2em;">再看示例： </p>
<p style="text-indent: 2em;">#pragma pack(push) // 将当前pack设置压栈保存 </p>
<p style="text-indent: 2em;">#pragma pack(2)// 必须在结构体定义之前使用 </p>
<p style="text-indent: 2em;">struct S1 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char c; </p>
<p style="text-indent: 2em;">int i; </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">struct S3 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char c1; </p>
<p style="text-indent: 2em;">S1 s; </p>
<p style="text-indent: 2em;">char c2 </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">#pragma pack(pop) // 恢复先前的pack设置 </p>
<p style="text-indent: 2em;">计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)等于</p>
<p style="text-indent: 2em;">6，能够被2整除，所以整个S1的大小为6。 </p>
<p style="text-indent: 2em;">同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能被</p>
<p style="text-indent: 2em;">2整除，添加一个填充字节，所以sizeof(S3)等于10。 </p>
<p style="text-indent: 2em;">现在，朋友们可以轻松的出一口气了， </p>
<p style="text-indent: 2em;">还有一点要注意，“空结构体”（不含数据成员）的大小不为0，而是1。试想一个“不占</p>
<p style="text-indent: 2em;">空间”的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢？于是，“</p>
<p style="text-indent: 2em;">空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。</p>
<p style="text-indent: 2em;">如下： </p>
<p style="text-indent: 2em;">struct S5 { }; </p>
<p style="text-indent: 2em;">sizeof( S5 ); // 结果为1 </p>
<p style="text-indent: 2em;">8. 含位域结构体的sizeof </p>
<p style="text-indent: 2em;">前面已经说过，位域成员不能单独被取sizeof值，我们这里要讨论的是含有位域的结构体</p>
<p style="text-indent: 2em;">的sizeof，只是考虑到其特殊性而将其专门列了出来。 </p>
<p style="text-indent: 2em;">C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允</p>
<p style="text-indent: 2em;">许其它类型类型的存在。 </p>
<p style="text-indent: 2em;">使用位域的主要目的是压缩存储，其大致规则为： </p>
<p style="text-indent: 2em;">1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将</p>
<p style="text-indent: 2em;">紧邻前一个字段存储，直到不能容纳为止； </p>
<p style="text-indent: 2em;">2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将</p>
<p style="text-indent: 2em;">从新的存储单元开始，其偏移量为其类型大小的整数倍； </p>
<p style="text-indent: 2em;">3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式</p>
<p style="text-indent: 2em;">，Dev-C++采取压缩方式； </p>
<p style="text-indent: 2em;">4) 如果位域字段之间穿插着非位域字段，则不进行压缩； </p>
<p style="text-indent: 2em;">5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。 </p>
<p style="text-indent: 2em;">还是让我们来看看例子。 </p>
<p style="text-indent: 2em;">示例1： </p>
<p style="text-indent: 2em;">struct BF1 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char f1 : 3; </p>
<p style="text-indent: 2em;">char f2 : 4; </p>
<p style="text-indent: 2em;">char f3 : 5; </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">其内存布局为： </p>
<p style="text-indent: 2em;">|_f1__|__f2__|_|____f3___|____| </p>
<p style="text-indent: 2em;">|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| </p>
<p style="text-indent: 2em;">0 3&nbsp;&nbsp; 7 8&nbsp;&nbsp; 1316 </p>
<p style="text-indent: 2em;">位域类型为char，第1个字节仅能容纳下f1和f2，所以f2被压缩到第1个字节中，而f3只能</p>
<p style="text-indent: 2em;">从下一个字节开始。因此sizeof(BF1)的结果为2。 </p>
<p style="text-indent: 2em;">示例2： </p>
<p style="text-indent: 2em;">struct BF2 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char f1 : 3; </p>
<p style="text-indent: 2em;">short f2 : 4; </p>
<p style="text-indent: 2em;">char f3 : 5; </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。 </p>
<p style="text-indent: 2em;">示例3： </p>
<p style="text-indent: 2em;">struct BF3 </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">char f1 : 3; </p>
<p style="text-indent: 2em;">char f2; </p>
<p style="text-indent: 2em;">char f3 : 5; </p>
<p style="text-indent: 2em;">}; </p>
<p style="text-indent: 2em;">非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。 </p>
<p style="text-indent: 2em;">9. 联合体的sizeof </p>
<p style="text-indent: 2em;">结构体在内存组织上是顺序式的，联合体则是重叠式，各成员共享一段内存，所以整个联</p>
<p style="text-indent: 2em;">合体的sizeof也就是每个成员sizeof的最大值。结构体的成员也可以是复合类型，这里，</p>
<p style="text-indent: 2em;">复合类型成员是被作为整体考虑的。 </p>
<p style="text-indent: 2em;">所以，下面例子中，U的sizeof值等于sizeof(s)。 </p>
<p style="text-indent: 2em;">union U </p>
<p style="text-indent: 2em;">{ </p>
<p style="text-indent: 2em;">int i; </p>
<p style="text-indent: 2em;">char c; </p>
<p style="text-indent: 2em;">S1 s; </p>
<p style="text-indent: 2em;">};</p>
</div>
<div class="share_buttons" id="sharePanel"><span>分享到：</span> <a name="sina" class="share_sina" title="分享到新浪微博"></a><a name="qq" class="share_qq" title="分享到腾讯微博"></a></div>
<!--192.168.1.237-->
<div class="article_next_prev">
    <li class="prev_article"><span>上一篇：</span><a href="http://blog.csdn.net/shenbin1430/article/details/4292457">c#程序集的定义</a></li>
    <li class="next_article"><span>下一篇：</span><a href="http://blog.csdn.net/shenbin1430/article/details/4292477">堆和栈的区别</a></li>
</div>


    
</div>
<div id="ad_cen"><iframe src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ad.htm" style="border-width: 0px; overflow: hidden; width: 732px; height: 96px;" id="ad_frm_0" frameborder="0" scrolling="no"></iframe></div>
<script type="text/javascript">
    new Ad(4, 'ad_cen');
</script>
<div id="comment_title" class="panel_head">查看评论<a name="comments"></a></div>
<div id="comment_list"><dl class="comment_item comment_topic" id="comment_item_1527531"><dt class="comment_head" floor="1">1楼 <span class="user"><a class="username" href="http://blog.csdn.net/googya" target="_blank">googya</a> <span class="ptime">2010-11-07 17:16发表</span>  <a href="#reply" class="cmt_btn reply" title="回复">[回复]</a> <span class="comment_manage" style="display:none;" commentid="1527531" username="googya"> <a href="#quote" class="cmt_btn quote" title="引用">[引用]</a> <a href="#report" class="cmt_btn report" title="举报">[举报]</a></span></span></dt><dd class="comment_userface"><a href="http://blog.csdn.net/googya" target="_blank"><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/3_googya.jpg" height="40" width="40"></a></dd><dd class="comment_body">现在才知道这个玩意的重要性</dd></dl><div class="clear"></div></div>
<div style="display: none;" id="comment_bar"></div>
<div id="comment_form"><div class="guest_link">您还没有登录,请<a href="http://passport.csdn.net/account/login?from=http%3A%2F%2Fblog.csdn.net%2Fshenbin1430%2Farticle%2Fdetails%2F4292463">[登录]</a>或<a href="http://passport.csdn.net/account/register?from=http%3A%2F%2Fblog.csdn.net%2Fshenbin1430%2Farticle%2Fdetails%2F4292463">[注册]</a></div></div>
<div class="announce">* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<a name="reply"></a><a name="quote"></a></div>
<script type="text/javascript">
    var fileName = '4292463';
    var commentscount = 1;
    var islock = false
</script>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/comment.js"></script>
<div id="ad_bot"><iframe src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ad_002.htm" style="border-width: 0px; overflow: hidden; width: 732px; height: 170px;" id="ad_frm_1" frameborder="0" scrolling="no"></iframe></div>
<script type="text/javascript">
    new Ad(5, 'ad_bot');
</script>
<div id="report_dialog"></div>

<div id="d-top">
<a href="#" onclick="javascript:document.body.scrollTop=0;document.documentElement.scrollTop=0;this.blur();return false;" title="回到顶部">
<img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/top.png" alt="TOP"></a>
</div>



<div class="clear"></div>
</div>
</div>

<div id="side">
<div class="side">
<div id="panel_Profile" class="panel">
    <ul class="panel_head"><span>个人资料</span></ul>
    <ul class="panel_body profile">
        <div id="blog_userface">
            <a href="http://my.csdn.net/shenbin1430" target="_blank">
            <img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/1_shenbin1430.jpg" title="访问我的空间" style="max-width:90%">
            </a>
            <br>
            <span><a href="http://my.csdn.net/shenbin1430" class="user_name" target="_blank">shenbin1430</a></span>
        </div>
<div class="interact">
<!--<a href="#" class="attented" title="已关注"></a>-->
<a href="#" class="attent" id="span_add_follow" title="[加关注]"></a>
<a href="http://my.csdn.net/my/letter/send/shenbin1430" class="letter" title="[发私信]"></a>
</div>
        <div id="blog_medal">
        <div id="bms_box"></div></div>
        <ul id="blog_rank">
            <li>访问：<span>123138次</span></li>
            <li>积分：<span>1948分</span></li>
            <li>排名：<span>第3405名</span></li>
        </ul>
        <ul id="blog_statistics">
            <li>原创：<span>41篇</span></li>
            <li>转载：<span>122篇</span></li>
            <li>译文：<span>1篇</span></li>
            <li>评论：<span>86条</span></li>
        </ul>
    </ul>
</div>
<script type="text/javascript">
    var _blogger = 'shenbin1430';
</script>
<script type="text/javascript">
$(document).ready(function () {
    var un = getUN().toLowerCase();
    if (un == _blogger.toLowerCase()) {
        $('.interact').hide();
    } else if(un) {
        var url = "http://my.csdn.net/index.php/follow/check_is_followed/" + encodeURIComponent(un) + "/" + encodeURIComponent(_blogger) + "?jsonpcallback=?";
        $.getJSON(url, {}, function (data) {
            if (data.succ == 1 && data.info == 1) {
                $('#span_add_follow').attr('class', 'attented');
            } else {
                $('#span_add_follow').click(guanzhu);
            }
        }, 'json');
    }
});
function guanzhu() {
    var url = "http://my.csdn.net/index.php/follow/do_follow?jsonpcallback=?";
    $.getJSON(url, { "username": _blogger }, function (data) {
        if (data.succ == 1) {
            alert('关注成功！');
            $('#span_add_follow').attr('class', 'attented').click(function () { return false; });
        } else {
            alert(data.msg);
        }
    });
    return false;
}
function getUN() {
    var m = document.cookie.match(new RegExp("(^| )UserName=([^;]*)(;|$)"));
    if (m) return m[2];
    else return '';
}
</script>

<div class="panel" id="panel_Search">
    <ul class="panel_head"><span>文章搜索</span></ul>
    <ul class="panel_body">
        <form id="frmSearch" action="http://so.csdn.net/search" class="form_search" target="_blank">
        <span><input id="inputSearch" class="blogsearch" title="请输入关键字" type="text"></span>
        <input id="btnSubmit" value="搜索" title="search in blog" type="submit">
        <input name="q" id="inputQ" type="hidden">
        <input name="t" value="blog" type="hidden">
        <a id="btnSearchBlog" target="_blank"></a>
        </form>
    </ul>
</div><div id="panel_Category" class="panel">
    <ul class="panel_head"><span>文章分类</span></ul>
    <ul class="panel_body">
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/558450">Android系统</a><span>(33)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/560487">J2EE开发</a><span>(8)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/542115">Linux系统</a><span>(21)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/559742">Moblin平台</a><span>(4)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/602878">Windows</a><span>(4)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/558479">多媒体技术</a><span>(43)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/573088">嵌入式与驱动开发</a><span>(21)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/797242">服务器与云计算</a><span>(12)</span>
        </li>
        <li>
        <a href="http://blog.csdn.net/shenbin1430/article/category/558503">程序设计</a><span>(12)</span>
        </li>
    </ul>
</div><div id="panel_Archive" class="panel">
    <ul class="panel_head"><span>文章存档</span></ul>
    <ul class="panel_body">
        <div id="archive_list"><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/11">2011年11月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/09">2011年09月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/08">2011年08月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/07">2011年07月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/06">2011年06月</a><span>(1)</span></li><span class="hidelist" style="display:none;"><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/05">2011年05月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/04">2011年04月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2011/03">2011年03月</a><span>(7)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/12">2010年12月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/10">2010年10月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/09">2010年09月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/07">2010年07月</a><span>(4)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/06">2010年06月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/05">2010年05月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/04">2010年04月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/03">2010年03月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/02">2010年02月</a><span>(1)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2010/01">2010年01月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/12">2009年12月</a><span>(3)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/11">2009年11月</a><span>(2)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/10">2009年10月</a><span>(5)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/09">2009年09月</a><span>(21)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/08">2009年08月</a><span>(12)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/07">2009年07月</a><span>(33)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/06">2009年06月</a><span>(48)</span></li><li><a href="http://blog.csdn.net/shenbin1430/article/month/2009/05">2009年05月</a><span>(1)</span></li></span><div id="archive_list_button" class="list_closed">展开</div></div>
    </ul>
</div>
<div id="hotarticls" class="panel">
    <ul class="panel_head"><span>阅读排行</span></ul>
    <ul class="panel_body itemlist">
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4355921" title="OpenMAX简介">OpenMAX简介</a><span>(8553)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4291963" title="Gstreamer的一些基本概念与A/V同步分析">Gstreamer的一些基本概念与A/V同步分析</a><span>(4302)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4343584" title="Android多媒体之OpenCore的A/V同步机制">Android多媒体之OpenCore的A/V同步机制</a><span>(3949)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4344897" title="Android图形架构实现分析总结">Android图形架构实现分析总结</a><span>(3858)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/5444726" title="Camera原理">Camera原理</a><span>(3348)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4324456" title="Android的MediaPlayer架构介绍">Android的MediaPlayer架构介绍</a><span>(2504)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4318996" title="Android多媒体框架初步分析">Android多媒体框架初步分析</a><span>(2227)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4391566" title="NAND FLASH 内存详解与读写寻址方式">NAND FLASH 内存详解与读写寻址方式</a><span>(2124)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4291780" title="Android 技术专题系列之十 －－ Audio manager">Android 技术专题系列之十 －－ Audio manager</a><span>(2044)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4319051" title="Android的多媒体框架OpenCore（PacketVideo）介绍">Android的多媒体框架OpenCore（PacketVideo）介绍</a><span>(1976)</span>
        </li>
    </ul>
</div>
<div id="hotarticls2" class="panel">
    <ul class="panel_head"><span>评论排行</span></ul>
    <ul class="panel_body itemlist">
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4343584" title="Android多媒体之OpenCore的A/V同步机制">Android多媒体之OpenCore的A/V同步机制</a><span>(20)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4324520" title="Android的MediaRecorder架构介绍">Android的MediaRecorder架构介绍</a><span>(8)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/5705033" title="用gstreamer抓取视频的缩略图">用gstreamer抓取视频的缩略图</a><span>(5)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4291780" title="Android 技术专题系列之十 －－ Audio manager">Android 技术专题系列之十 －－ Audio manager</a><span>(4)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/5563194" title="Linux TCP Socket程序分析">Linux TCP Socket程序分析</a><span>(3)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4355921" title="OpenMAX简介">OpenMAX简介</a><span>(3)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4708244" title=" Linux下ALSA声卡编程"> Linux下ALSA声卡编程</a><span>(3)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4305968" title="Spring+Hibernate+WebWork配置">Spring+Hibernate+WebWork配置</a><span>(3)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4291963" title="Gstreamer的一些基本概念与A/V同步分析">Gstreamer的一些基本概念与A/V同步分析</a><span>(3)</span>
        </li>
        <li>
            <a href="http://blog.csdn.net/shenbin1430/article/details/4324967" title="Android的Camera架构介绍">Android的Camera架构介绍</a><span>(3)</span>
        </li>
    </ul>
</div>
<div id="homepageArticles" class="panel">
    <ul class="panel_head"><span>推荐文章</span></ul>
    <ul class="panel_body" id="ad_commend">
    <iframe src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ad_003.htm" style="border-width: 0px; overflow: hidden; width: 182px; height: 218px;" id="ad_frm_2" frameborder="0" scrolling="no"></iframe></ul>
</div>
<script type="text/javascript">
    new Ad(12, 'ad_commend');
</script><div id="newcomments" class="panel">
<ul class="panel_head"><span>最新评论</span></ul>
<ul class="panel_body itemlist">
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4291941#comments">FFPLAY的原理（七）</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/shenbin1430" class="user_name">shenbin1430</a>:
@p741953:ffplay其实是ffmpeg的一个例子程序，ffmpeg封装了音视频处理的库，用...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4291941#comments">FFPLAY的原理（七）</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/p741953" class="user_name">p741953</a>:
看了这个，我怎么分不清ffmpeg和ffplay的区别啊，都是调用libavcodec和libavf...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/5563194#comments">Linux TCP Socket程序分析</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/zhyk7003427" class="user_name">zhyk7003427</a>:
地址转换很讨厌
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4355921#comments">OpenMAX简介</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/zhejiang9" class="user_name">漫步小者</a>:
@xiaoye065:个人觉得应该就是将ffmpeg封装成OpenMAX IL的compnent，没...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4324520#comments">Android的MediaRecorder架构介绍</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/shenbin1430" class="user_name">shenbin1430</a>:
@bufanbinbufanbin:可以啊，这不就是录像的功能嘛
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/5705033#comments">用gstreamer抓取视频的缩略图</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/shenbin1430" class="user_name">shenbin1430</a>:
@bufanbinbufanbin:那样也可以的，只有知道从哪里到哪里，直接Seek就行。
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/5705033#comments">用gstreamer抓取视频的缩略图</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/bufanbinbufanbin" class="user_name">bufanbinbufanbin</a>:
麻烦楼主，如水果不是把每一帧都提提取出来，能不能这样，每隔很小一段时间截取一段视频，保存为可播放的视...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4324520#comments">Android的MediaRecorder架构介绍</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/bufanbinbufanbin" class="user_name">bufanbinbufanbin</a>:
我想问楼主一个问题，我能不能把摄像头捕捉的视频，保存为一段一段的可播放的文件啊？（一遍一遍录制一边保...
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4324520#comments">Android的MediaRecorder架构介绍</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/bufanbinbufanbin" class="user_name">bufanbinbufanbin</a>:
顶楼主！很详细！学习了。
    </p>
    </li>
    <li>
    <a href="http://blog.csdn.net/shenbin1430/article/details/4305968#comments">Spring+Hibernate+WebWork配置</a>
    <p style="margin:0px;"><a href="http://blog.csdn.net/shenbin1430" class="user_name">shenbin1430</a>:
@jiebing:配置JDBC和Mysql那段就是阿，有这些就够了。
    </p>
    </li>
</ul>
</div>
</div>
<div class="clear"></div>
</div>

<div class="clear"></div>
</div>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/shCore-src.js"></script>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ZeroClipboard.js"></script>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/article_code.js"></script>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/cnick.js"></script>

<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/show.js"></script>
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/showblogmedal.js"></script>

<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/publib_footer.js"></script><link rel="stylesheet" type="text/css" href="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/pub_footer_2012.css"><div class="pub_footerall"><dl><dt></dt> <dd><a href="http://www.csdn.net/company/about.html" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/recruit.html" target="_blank">招贤纳士</a>|<a href="http://www.csdn.net/company/marketing.html" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" target="_blank">法律顾问</a>|<a href="mailto:webmaster@csdn.net">问题报告</a></dd><dd>京&nbsp;ICP&nbsp;证&nbsp;070598&nbsp;号</dd><dd>北京创新乐知信息技术有限公司 版权所有</dd><dd>世纪乐知(北京)网络技术有限公司 提供技术支持</dd><dd>江苏乐知网络技术有限公司 提供商务支持</dd><dd><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ico_email.gif" alt="" title=""> 联系邮箱：webmaster(at)csdn.net</dd><dd>Copyright © 1999-2012, CSDN.NET, All Rights Reserved&nbsp;<a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" target="_blank"><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/gongshang_logos.gif" alt="GongshangLogo" title=""></a></dd></dl></div>

<script type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</script><img src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/pv.txt" border="0" height="0" width="0">
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/counter.js"></script><script type="text/javascript" charset="UTF-8" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/msg.js"></script>

<!--ad.csdn.net-->
<script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ad-blog.js"></script><script type="text/javascript" src="C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90_files/ad-ibm432.js"></script>




</div>

</body></html>